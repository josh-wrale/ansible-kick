// Copyright 2013 Kelsey Hightower. All rights reserved.
// Use of this source code is governed by the Apache License, Version 2.0
// that can be found in the LICENSE file.
package main

import (
	"errors"
	"io"
	"io/ioutil"
	"launchpad.net/goamz/ec2"
	"log"
	"os"
	"os/exec"
	"path"
	"strings"
	"text/template"
)

type ansibleConfig struct {
	Host              string
	Role              string
	inventoryTempFile *os.File
	playbookFilePath  string
	extraVars         string
	settings          *config
}

func extraVarsFromTags(tags []ec2.Tag, extraVarTags []string) string {
	if len(extraVarTags) == 0 {
		return ""
	}
	extraVars := make([]string, 0, len(extraVarTags))
	for _, extraVarTag := range extraVarTags {
		for _, tag := range tags {
			if tag.Key == extraVarTag {
				if tag.Value != "" {
					extraVars = append(extraVars, tag.Key+"="+tag.Value)
				}
			}
		}
	}
	return "\"" + strings.Join(extraVars, " ") + "\""
}

// setRole sets the Ansible role based on ec2 tags of the target instance.
// If the target ec2 instance does not exist, or does not have a role tag
// value, then setRole returns an error explaining why the role could not
// be set.
func roleFromTags(tags []ec2.Tag, roleKey string) (string, error) {
	if len(tags) == 0 {
		return "", errors.New("tags list empty")
	}
	for _, tag := range tags {
		if tag.Key == roleKey {
			return tag.Value, nil
		}
	}
	return "", errors.New(roleKey + " tag not found")
}

// setPlaybookFilePath sets the path of the Ansible playbook file and
// returns an error if the playbook does not exist.
func (ac *ansibleConfig) setPlaybookFilePath() error {
	fn := path.Join(ac.settings.PlaybookPath, ac.Role+".yml")
	if _, err := os.Stat(fn); os.IsNotExist(err) {
		return errors.New("playbook does not exist " + fn)
	}
	ac.playbookFilePath = fn
	return nil
}

// setInventoryFile sets the path of the Ansible inventory file to a
// dynamically generated inventory file using an inventory template.
// It returns an error if the inventory file cannot be generated.
func (ac *ansibleConfig) setInventoryFile() error {
	var err error
	ac.inventoryTempFile, err = ioutil.TempFile("", "inventory")
	if err != nil {
		return err
	}
	t, err := template.New("hosts.tmpl").ParseFiles(ac.settings.InventoryTemplate)
	if err != nil {
		return err
	}
	if err := t.Execute(ac.inventoryTempFile, ac); err != nil {
		return err
	}
	return nil
}

// run executes an ansible-playbook run.
// It returns any error generated by the ansible-playbook command.
func (ac *ansibleConfig) run() error {
	var ansibleCmdArgs = []string{
		ac.playbookFilePath,
		"-i", ac.inventoryTempFile.Name(),
		"-l", ac.Host,
	}
	if ac.extraVars != "" {
		ansibleCmdArgs = append(ansibleCmdArgs, "--extra-vars", ac.extraVars)
	}

	log.Println(strings.Join(ansibleCmdArgs, " "))
	cmd := exec.Command(ac.settings.AnsibleCmd, ansibleCmdArgs...)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return err
	}
	stderr, err := cmd.StderrPipe()
	if err != nil {
		return err
	}
	err = cmd.Start()
	if err != nil {
		return err
	}
	go io.Copy(os.Stdout, stdout)
	go io.Copy(os.Stderr, stderr)
	return cmd.Wait()
}

// Run prepares and executes an ansible-playbook run for a specific host.
// It returns an error if any part of the preparation or execution fails.
func Run(host string) error {
	var err error
	ac := new(ansibleConfig)
	ac.Host = host
	ac.settings, err = loadConfig()
	if err != nil {
		return err
	}
	ec2Config := &EC2Config{
		ac.settings.AccessKeyID,
		ac.settings.SecretAccessKey,
		ac.settings.Region,
	}
	ec2Instance, err := ec2Config.findInstance(ac.Host)
	if err != nil {
		return err
	}

	tags := ec2Instance.Tags
	ac.Role, err = roleFromTags(tags, ac.settings.RoleKey)
	if err != nil {
		return err
	}

	ac.extraVars = extraVarsFromTags(tags, ac.settings.ExtraVarTags)

	ac.setInventoryFile()
	defer os.Remove(ac.inventoryTempFile.Name())
	defer ac.inventoryTempFile.Close()

	if err := ac.setPlaybookFilePath(); err != nil {
		return err
	}
	if err := ac.run(); err != nil {
		return err
	}
	return nil
}
